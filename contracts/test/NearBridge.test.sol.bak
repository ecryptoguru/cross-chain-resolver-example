// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "@openzeppelin-contracts/contracts/access/Ownable.sol";
import "@openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "../src/NearBridge.sol";

// MockToken contract for testing
contract MockToken {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
        _mint(msg.sender, 1000000 * 10**uint256(decimals));
    }
    
    function _mint(address to, uint256 value) internal {
        totalSupply += value;
        balanceOf[to] += value;
        emit Transfer(address(0), to, value);
    }
    
    function transfer(address to, uint256 value) public returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
    
    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Insufficient allowance");
        
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        
        emit Transfer(from, to, value);
        return true;
    }
}

contract NearBridgeTest is Test {
    // Custom error selectors
    bytes4 constant INVALID_RELAYER_ADDRESS_SELECTOR = bytes4(keccak256("InvalidRelayerAddress()"));
    bytes4 constant NOT_RELAYER_SELECTOR = bytes4(keccak256("NotRelayer()"));
    bytes4 constant ZERO_ADDRESS_SELECTOR = bytes4(keccak256("ZeroAddress()"));
    bytes4 constant INSUFFICIENT_BALANCE_SELECTOR = bytes4(keccak256("InsufficientBalance()"));
    bytes4 constant BLOCK_HEADER_ALREADY_EXISTS_SELECTOR = bytes4(keccak256("BlockHeaderAlreadyExists()"));
    bytes4 constant OWNABLE_UNAUTHORIZED_SELECTOR = bytes4(keccak256("OwnableUnauthorizedAccount(address)"));
    
    // Test contracts
    NearBridge public nearBridge;
    MockToken public token;
    
    // Test addresses
    address public owner = address(0x1);
    address public relayer = address(0x2);
    address public user = address(0x3);
    address public feeCollector = address(0x4);
    
    // Test constants
    uint256 public constant MIN_DEPOSIT = 0.1 ether;
    uint256 public constant MAX_DEPOSIT = 1000 ether;
    uint256 public constant DISPUTE_PERIOD = 1 days;
    uint256 public constant BRIDGE_FEE_BPS = 100; // 1%
    
    // Test block header
    struct BlockHeader {
        uint64 height;
        bytes32 prevBlockHash;
        bytes32 epochId;
        bytes32 nextEpochId;
        bytes32[] chunksIncluded;
        bytes32 hash;
        uint64 timestamp;
        bytes32 nextBpHash;
        bytes32 blockMerkleRoot;
    }
    
    BlockHeader public sampleBlockHeader;
    
    // Setup function
    function setUp() public {
        // Set up test accounts
        vm.startPrank(owner);
        
        // Deploy test token
        token = new MockToken("Test Token", "TEST");
        
        // Initialize sample block header
        sampleBlockHeader = BlockHeader({
            height: 1,
            prevBlockHash: keccak256("prevBlock"),
            epochId: keccak256("epoch1"),
            nextEpochId: keccak256("epoch2"),
            chunksIncluded: new bytes32[](0),
            hash: keccak256("block1"),
            timestamp: uint64(block.timestamp),
            nextBpHash: keccak256("nextBp"),
            blockMerkleRoot: keccak256("merkleRoot")
        });
        
        // Deploy NearBridge with test parameters
        nearBridge = new NearBridge(
            owner,              // owner
            address(token),     // feeToken
            address(0),         // accessToken (optional)
            owner,              // feeCollector
            0.1 ether,          // minDeposit
            1000 ether,         // maxDeposit
            1 days,             // disputePeriod
            100,                // bridgeFeeBps (1%)
            NearBridge.BridgeStatus.ACTIVE  // initialStatus
        );
        
        // Add relayer
        nearBridge.addRelayer(relayer);
        
        // Fund test accounts
        token.transfer(user, 1000 ether);
        
        vm.stopPrank();
    }
    
    // Test functions start here
    function test_Deployment() public {
        // Check owner
        assertEq(nearBridge.owner(), owner);
        
        // Check initial config
        (address feeCollectorAddr, uint256 minDeposit, uint256 maxDeposit, , uint256 bridgeFeeBps, ) = nearBridge.config();
        assertEq(feeCollectorAddr, feeCollector, "Incorrect fee collector");
        assertEq(minDeposit, MIN_DEPOSIT, "Incorrect min deposit");
        assertEq(maxDeposit, MAX_DEPOSIT, "Incorrect max deposit");
        assertEq(bridgeFeeBps, BRIDGE_FEE_BPS, "Incorrect bridge fee");
        
        // Check relayer was added
        assertTrue(nearBridge.relayers(relayer), "Relayer not added");
    }
    
    function test_AddRelayer() public {
        // Add a new relayer
        address newRelayer = address(0x5);
        
        vm.prank(owner);
        nearBridge.addRelayer(newRelayer);
        
        // Check relayer was added
        assertTrue(nearBridge.relayers(newRelayer), "New relayer not added");
    }
    
    function test_Revert_NonOwnerAddRelayer() public {
        // Non-owner should not be able to add relayer
        address newRelayer = address(0x5);
        
        vm.expectRevert(abi.encodeWithSelector(OWNABLE_UNAUTHORIZED_SELECTOR, user));
        vm.prank(user);
        nearBridge.addRelayer(newRelayer);
    }
    
    function test_Revert_AddZeroAddressAsRelayer() public {
        // Should not allow adding zero address as relayer
        vm.expectRevert(INVALID_RELAYER_ADDRESS_SELECTOR);
        vm.prank(owner);
        nearBridge.addRelayer(address(0));
    }
    
    function test_RemoveRelayer() public {
        // Remove relayer
        vm.prank(owner);
        nearBridge.removeRelayer(relayer);
        
        // Check relayer was removed
        assertFalse(nearBridge.relayers(relayer), "Relayer not removed");
    }
    
    // This test is commented out since pause/unpause functionality
    // doesn't exist in the current NearBridge contract
    // function test_Revert_NonOwnerPauseUnpause() public {
    //     vm.expectRevert(abi.encodeWithSelector(OWNABLE_UNAUTHORIZED_SELECTOR, user));
    //     vm.prank(user);
    //     nearBridge.pause();
    // }
    
    function test_DepositEth() public {
        uint256 depositAmount = 1 ether;
        
        // Make ETH deposit
        vm.prank(user);
        vm.deal(user, depositAmount);
        nearBridge.depositEth{value: depositAmount}(
            "test.near",
            keccak256("secret"),
            block.timestamp + 1 days
        );
        
        // Check contract received ETH
        assertEq(address(nearBridge).balance, depositAmount);
    }
    
    function test_DepositToken() public {
        uint256 depositAmount = 100 ether;
        
        // Set token as supported
        vm.prank(owner);
        nearBridge.setSupportedToken(address(token), true);
        
        // Approve and deposit tokens
        vm.prank(user);
        token.approve(address(nearBridge), depositAmount);
        
        vm.prank(user);
        nearBridge.depositToken(
            address(token),
            depositAmount,
            "test.near",
            keccak256("secret"),
            block.timestamp + 1 days
        );
        
        // Check tokens were transferred
        assertEq(token.balanceOf(address(nearBridge)), depositAmount);
    }
    
    function test_EmergencyWithdraw() public {
        // Send some ETH to the contract
        uint256 amount = 1 ether;
        
        vm.deal(address(nearBridge), amount);
        
        // Withdraw ETH
        uint256 initialBalance = owner.balance;
        
        vm.prank(owner);
        nearBridge.emergencyWithdraw(owner, amount);
        
        // Check balances
        assertEq(address(nearBridge).balance, 0);
        assertEq(owner.balance, initialBalance + amount);
    }
    
    function test_Revert_NonOwnerEmergencyWithdraw() public {
        // Non-owner should not be able to withdraw
        vm.expectRevert(abi.encodeWithSelector(OWNABLE_UNAUTHORIZED_SELECTOR, user));
        vm.prank(user);
        nearBridge.emergencyWithdraw(user, 1 ether);
    }
    
    function test_Revert_WithdrawToZeroAddress() public {
        // Should not allow withdrawing to zero address
        vm.expectRevert(ZERO_ADDRESS_SELECTOR);
        vm.prank(owner);
        nearBridge.emergencyWithdraw(address(0), 1 ether);
    }
    
    function test_Revert_WithdrawInsufficientBalance() public {
        // Contract has no balance
        uint256 contractBalance = address(nearBridge).balance;
        
        // Try to withdraw more than the balance
        vm.expectRevert(INSUFFICIENT_BALANCE_SELECTOR);
        vm.prank(owner);
        nearBridge.emergencyWithdraw(owner, contractBalance + 1);
    }
    
    // Helper function to create a deposit for testing
    function _createTestDeposit(address _user, uint256 amount) internal returns (bytes32) {
        // This is a simplified version - in a real test, you'd need to implement
        // the full deposit flow with proper signatures, etc.
        vm.startPrank(_user);
        token.approve(address(nearBridge), amount);
        // Note: This is a placeholder - the actual deposit function may have different parameters
        // and requirements in your implementation
        bytes32 depositId = keccak256(abi.encodePacked(_user, amount, block.timestamp));
        // Add deposit directly to the mapping for testing
        vm.stopPrank();
        return depositId;
    }

    // Helper function to get deposit info
    function _getDepositInfo(bytes32 depositId) internal view returns (address depositor, uint256 amount, bool claimed, bool disputed) {
        (bool success, bytes memory data) = address(nearBridge).staticcall(
            abi.encodeWithSignature("deposits(bytes32)", depositId)
        );
        require(success, "Failed to get deposit info");
        
        // Decode the deposit data
        (depositor, amount, claimed, disputed) = abi.decode(
            data,
            (address, uint256, bool, bool)
        );
    }
}