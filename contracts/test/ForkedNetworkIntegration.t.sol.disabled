// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/NearBridge.sol";
import "../src/adapters/TokenAdapter.sol";
import "@openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol";

/**
 * @title Forked Network Integration Tests
 * @dev Tests NearBridge with real mainnet tokens using forked networks
 * @notice Run with: forge test --fork-url $MAINNET_RPC_URL --match-contract ForkedNetworkIntegrationTest
 */
contract ForkedNetworkIntegrationTest is Test {
    using ECDSA for bytes32;
    
    NearBridge public bridge;
    TokenAdapter public adapter;
    
    // Real mainnet token addresses
    address constant USDC = 0xA0b86a33E6441d1F6f0b8c2c5e8b8B8b8B8b8B8b; // USDC mainnet
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;  // DAI
    
    // Known whale addresses for funding tests
    address constant USDC_WHALE = 0x55FE002aefF02F77364de339a1292923A15844B8; // Circle
    address constant WETH_WHALE = 0x2F0b23f53734252Bda2277357e97e1517d6B042A; // Gemini
    address constant DAI_WHALE = 0x66F62574ab04989737228D18C3624f7FC1edAe14;  // MakerDAO
    
    // Test accounts
    address public deployer;
    address public user;
    address public feeCollector;
    address public relayer1;
    address public relayer2;
    
    // Private keys for relayers
    uint256 private constant RELAYER1_KEY = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;
    uint256 private constant RELAYER2_KEY = 0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890;
    
    // Test constants
    uint256 public constant USDC_DEPOSIT_AMOUNT = 1000 * 10 ** 6; // 1000 USDC
    uint256 public constant DAI_DEPOSIT_AMOUNT = 1000 * 10 ** 18; // 1000 DAI
    uint256 public constant WETH_DEPOSIT_AMOUNT = 1 * 10 ** 18; // 1 WETH
    uint256 public constant ETH_DEPOSIT_AMOUNT = 1 ether;
    string public constant NEAR_ACCOUNT = "forked-test.near";
    
    // Events
    event DepositInitiated(bytes32 indexed depositId, address indexed sender, string nearRecipient, address token, uint256 amount, uint256 fee, uint256 timestamp);
    event WithdrawalCompleted(bytes32 indexed depositId, address indexed recipient, uint256 amount, uint256 timestamp);
    
    function setUp() public {
        // Skip if not running on forked network
        if (block.chainid != 1) {
            vm.skip(true);
            return;
        }
        
        // Set up accounts
        deployer = address(this);
        user = address(0x2);
        feeCollector = address(0x3);
        relayer1 = vm.addr(RELAYER1_KEY);
        relayer2 = vm.addr(RELAYER2_KEY);
        
        // Deploy adapter
        adapter = new TokenAdapter(deployer);
        
        // Deploy bridge with USDC as fee token
        bridge = new NearBridge(
            deployer,                    // _owner
            USDC,                       // _feeToken (USDC)
            address(0),                 // _accessToken (optional)
            feeCollector,               // _feeCollector
            1 * 10 ** 6,               // _minDeposit (1 USDC)
            1000000 * 10 ** 6,         // _maxDeposit (1M USDC)
            7 days,                     // _disputePeriod
            30,                         // _bridgeFeeBps (0.3%)
            NearBridge.BridgeStatus.ACTIVE // _initialStatus
        );
        
        // Add relayers
        bridge.addRelayer(relayer1);
        bridge.addRelayer(relayer2);
        bridge.setRequiredConfirmations(2);
        
        // Set up supported tokens
        bridge.setSupportedToken(WETH, true);
        bridge.setSupportedToken(DAI, true);
        
        // Fund test accounts with real tokens
        _fundAccountWithUSDC(user, 10000 * 10 ** 6); // 10,000 USDC
        _fundAccountWithWETH(user, 10 * 10 ** 18); // 10 WETH
        _fundAccountWithDAI(user, 10000 * 10 ** 18); // 10,000 DAI
        
        // Give accounts ETH for gas
        vm.deal(user, 10 ether);
        vm.deal(deployer, 10 ether);
        vm.deal(feeCollector, 1 ether);
    }
    
    // ============ Real Token Integration Tests ============
    
    function testFork_DepositUSDCToNear() public {
        if (block.chainid != 1) return;
        
        vm.startPrank(user);
        
        // Check initial balances
        uint256 userBalanceBefore = IERC20(USDC).balanceOf(user);
        uint256 bridgeBalanceBefore = IERC20(USDC).balanceOf(address(bridge));
        uint256 feeCollectorBalanceBefore = IERC20(USDC).balanceOf(feeCollector);
        
        // Approve and deposit USDC
        IERC20(USDC).approve(address(bridge), USDC_DEPOSIT_AMOUNT);
        
        vm.recordLogs();
        bridge.depositToken(
            USDC,
            USDC_DEPOSIT_AMOUNT,
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("usdc-integration-secret")),
            block.timestamp + 1 days
        );
        
        // Verify event emission
        Vm.Log[] memory logs = vm.getRecordedLogs();
        bool depositEventFound = false;
        bytes32 depositId;
        
        for (uint i = 0; i < logs.length; i++) {
            if (logs[i].topics[0] == keccak256("DepositInitiated(bytes32,address,string,address,uint256,uint256,uint256)")) {
                depositEventFound = true;
                depositId = logs[i].topics[1];
                break;
            }
        }
        
        assertTrue(depositEventFound, "DepositInitiated event should be emitted");
        
        // Verify balances changed correctly
        uint256 expectedFee = (USDC_DEPOSIT_AMOUNT * 30) / 10000; // 0.3% fee
        uint256 expectedAmountAfterFee = USDC_DEPOSIT_AMOUNT - expectedFee;
        
        assertEq(
            IERC20(USDC).balanceOf(user),
            userBalanceBefore - USDC_DEPOSIT_AMOUNT,
            "User balance should decrease by deposit amount"
        );
        
        assertEq(
            IERC20(USDC).balanceOf(address(bridge)),
            bridgeBalanceBefore + expectedAmountAfterFee,
            "Bridge should hold amount after fees"
        );
        
        assertEq(
            IERC20(USDC).balanceOf(feeCollector),
            feeCollectorBalanceBefore + expectedFee,
            "Fee collector should receive fee"
        );
        
        vm.stopPrank();
    }
    
    function testFork_DepositWETHToNear() public {
        if (block.chainid != 1) return;
        
        vm.startPrank(user);
        
        // Check initial balances
        uint256 userBalanceBefore = IERC20(WETH).balanceOf(user);
        uint256 bridgeBalanceBefore = IERC20(WETH).balanceOf(address(bridge));
        
        // Approve and deposit WETH
        IERC20(WETH).approve(address(bridge), WETH_DEPOSIT_AMOUNT);
        
        vm.recordLogs();
        bridge.depositToken(
            WETH,
            WETH_DEPOSIT_AMOUNT,
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("weth-integration-secret")),
            block.timestamp + 1 days
        );
        
        // Verify balances
        uint256 expectedFee = (WETH_DEPOSIT_AMOUNT * 30) / 10000; // 0.3% fee
        uint256 expectedAmountAfterFee = WETH_DEPOSIT_AMOUNT - expectedFee;
        
        assertEq(
            IERC20(WETH).balanceOf(user),
            userBalanceBefore - WETH_DEPOSIT_AMOUNT,
            "User WETH balance should decrease"
        );
        
        assertEq(
            IERC20(WETH).balanceOf(address(bridge)),
            bridgeBalanceBefore + expectedAmountAfterFee,
            "Bridge should hold WETH after fees"
        );
        
        vm.stopPrank();
    }
    
    function testFork_DepositDAIToNear() public {
        if (block.chainid != 1) return;
        
        vm.startPrank(user);
        
        // Check initial balances
        uint256 userBalanceBefore = IERC20(DAI).balanceOf(user);
        uint256 bridgeBalanceBefore = IERC20(DAI).balanceOf(address(bridge));
        
        // Approve and deposit DAI
        IERC20(DAI).approve(address(bridge), DAI_DEPOSIT_AMOUNT);
        
        vm.recordLogs();
        bridge.depositToken(
            DAI,
            DAI_DEPOSIT_AMOUNT,
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("dai-integration-secret")),
            block.timestamp + 1 days
        );
        
        // Verify balances
        uint256 expectedFee = (DAI_DEPOSIT_AMOUNT * 30) / 10000; // 0.3% fee
        uint256 expectedAmountAfterFee = DAI_DEPOSIT_AMOUNT - expectedFee;
        
        assertEq(
            IERC20(DAI).balanceOf(user),
            userBalanceBefore - DAI_DEPOSIT_AMOUNT,
            "User DAI balance should decrease"
        );
        
        assertEq(
            IERC20(DAI).balanceOf(address(bridge)),
            bridgeBalanceBefore + expectedAmountAfterFee,
            "Bridge should hold DAI after fees"
        );
        
        vm.stopPrank();
    }
    
    function testFork_DepositETHToNear() public {
        if (block.chainid != 1) return;
        
        vm.startPrank(user);
        
        // Check initial balances
        uint256 userBalanceBefore = user.balance;
        uint256 bridgeBalanceBefore = address(bridge).balance;
        
        // Deposit ETH
        vm.recordLogs();
        bridge.depositEth{value: ETH_DEPOSIT_AMOUNT}(
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("eth-integration-secret")),
            block.timestamp + 1 days
        );
        
        // Verify balances (accounting for gas costs)
        uint256 expectedFee = (ETH_DEPOSIT_AMOUNT * 30) / 10000; // 0.3% fee
        uint256 expectedAmountAfterFee = ETH_DEPOSIT_AMOUNT - expectedFee;
        
        assertLt(
            user.balance,
            userBalanceBefore - ETH_DEPOSIT_AMOUNT,
            "User ETH balance should decrease by more than 1 ETH (including gas)"
        );
        
        assertEq(
            address(bridge).balance,
            bridgeBalanceBefore + expectedAmountAfterFee,
            "Bridge should hold ETH after fees"
        );
        
        vm.stopPrank();
    }
    
    // ============ Complete Withdrawal Flow Tests ============
    
    function testFork_CompleteUSDCWithdrawalFlow() public {
        if (block.chainid != 1) return;
        
        // First, create a deposit
        vm.startPrank(user);
        IERC20(USDC).approve(address(bridge), USDC_DEPOSIT_AMOUNT);
        
        vm.recordLogs();
        bridge.depositToken(
            USDC,
            USDC_DEPOSIT_AMOUNT,
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("usdc-withdrawal-secret")),
            block.timestamp + 1 days
        );
        
        // Extract deposit ID from logs
        Vm.Log[] memory logs = vm.getRecordedLogs();
        bytes32 depositId;
        for (uint i = 0; i < logs.length; i++) {
            if (logs[i].topics[0] == keccak256("DepositInitiated(bytes32,address,string,address,uint256,uint256,uint256)")) {
                depositId = logs[i].topics[1];
                break;
            }
        }
        vm.stopPrank();
        
        // Generate valid signatures for withdrawal
        uint256 expectedAmountAfterFee = USDC_DEPOSIT_AMOUNT - ((USDC_DEPOSIT_AMOUNT * 30) / 10000);
        bytes[] memory signatures = _generateValidSignatures(depositId, user, expectedAmountAfterFee);
        
        // Record balances before withdrawal
        uint256 userBalanceBefore = IERC20(USDC).balanceOf(user);
        uint256 bridgeBalanceBefore = IERC20(USDC).balanceOf(address(bridge));
        
        // Complete withdrawal
        vm.expectEmit(address(bridge));
        emit WithdrawalCompleted(depositId, user, expectedAmountAfterFee, block.timestamp);
        
        bridge.completeWithdrawal(
            depositId,
            user,
            "usdc-withdrawal-secret",
            signatures
        );
        
        // Verify balances after withdrawal
        assertEq(
            IERC20(USDC).balanceOf(user),
            userBalanceBefore + expectedAmountAfterFee,
            "User should receive amount after fees"
        );
        
        assertEq(
            IERC20(USDC).balanceOf(address(bridge)),
            bridgeBalanceBefore - expectedAmountAfterFee,
            "Bridge balance should decrease"
        );
    }
    
    function testFork_CompleteETHWithdrawalFlow() public {
        if (block.chainid != 1) return;
        
        // First, create an ETH deposit
        vm.startPrank(user);
        
        vm.recordLogs();
        bridge.depositEth{value: ETH_DEPOSIT_AMOUNT}(
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("eth-withdrawal-secret")),
            block.timestamp + 1 days
        );
        
        // Extract deposit ID from logs
        Vm.Log[] memory logs = vm.getRecordedLogs();
        bytes32 depositId;
        for (uint i = 0; i < logs.length; i++) {
            if (logs[i].topics[0] == keccak256("DepositInitiated(bytes32,address,string,address,uint256,uint256,uint256)")) {
                depositId = logs[i].topics[1];
                break;
            }
        }
        vm.stopPrank();
        
        // Generate valid signatures for withdrawal
        uint256 expectedAmountAfterFee = ETH_DEPOSIT_AMOUNT - ((ETH_DEPOSIT_AMOUNT * 30) / 10000);
        bytes[] memory signatures = _generateValidSignatures(depositId, user, expectedAmountAfterFee);
        
        // Record balances before withdrawal
        uint256 userBalanceBefore = user.balance;
        uint256 bridgeBalanceBefore = address(bridge).balance;
        
        // Complete withdrawal
        vm.expectEmit(address(bridge));
        emit WithdrawalCompleted(depositId, user, expectedAmountAfterFee, block.timestamp);
        
        bridge.completeWithdrawal(
            depositId,
            user,
            "eth-withdrawal-secret",
            signatures
        );
        
        // Verify balances after withdrawal
        assertEq(
            user.balance,
            userBalanceBefore + expectedAmountAfterFee,
            "User should receive ETH amount after fees"
        );
        
        assertEq(
            address(bridge).balance,
            bridgeBalanceBefore - expectedAmountAfterFee,
            "Bridge ETH balance should decrease"
        );
    }
    
    // ============ Stress Tests with Real Tokens ============
    
    function testFork_HighVolumeUSDCDeposits() public {
        if (block.chainid != 1) return;
        
        vm.startPrank(user);
        
        // Make multiple deposits to test gas efficiency and state management
        uint256 numDeposits = 5;
        bytes32[] memory depositIds = new bytes32[](numDeposits);
        
        for (uint i = 0; i < numDeposits; i++) {
            IERC20(USDC).approve(address(bridge), USDC_DEPOSIT_AMOUNT);
            
            vm.recordLogs();
            bridge.depositToken(
                USDC,
                USDC_DEPOSIT_AMOUNT,
                NEAR_ACCOUNT,
                keccak256(abi.encodePacked("stress-test", i)),
                block.timestamp + 1 days
            );
            
            // Extract deposit ID
            Vm.Log[] memory logs = vm.getRecordedLogs();
            for (uint j = 0; j < logs.length; j++) {
                if (logs[j].topics[0] == keccak256("DepositInitiated(bytes32,address,string,address,uint256,uint256,uint256)")) {
                    depositIds[i] = logs[j].topics[1];
                    break;
                }
            }
        }
        
        vm.stopPrank();
        
        // Verify all deposits are unique and stored correctly
        for (uint i = 0; i < numDeposits; i++) {
            for (uint j = i + 1; j < numDeposits; j++) {
                assertTrue(depositIds[i] != depositIds[j], "All deposit IDs should be unique");
            }
        }
        
        // Verify bridge holds correct total amount
        uint256 expectedTotalAfterFees = numDeposits * (USDC_DEPOSIT_AMOUNT - ((USDC_DEPOSIT_AMOUNT * 30) / 10000));
        assertGe(
            IERC20(USDC).balanceOf(address(bridge)),
            expectedTotalAfterFees,
            "Bridge should hold total amount after fees"
        );
    }
    
    function testFork_MaximumUSDCDepositAmount() public {
        if (block.chainid != 1) return;
        
        uint256 maxAmount = 1000000 * 10 ** 6; // 1M USDC (bridge's max)
        
        // Fund user with max amount
        _fundAccountWithUSDC(user, maxAmount);
        
        vm.startPrank(user);
        IERC20(USDC).approve(address(bridge), maxAmount);
        
        // Should succeed with max amount
        bridge.depositToken(
            USDC,
            maxAmount,
            NEAR_ACCOUNT,
            keccak256(abi.encodePacked("max-usdc-secret")),
            block.timestamp + 1 days
        );
        
        vm.stopPrank();
        
        // Verify deposit succeeded
        uint256 expectedAmountAfterFee = maxAmount - ((maxAmount * 30) / 10000);
        assertGe(
            IERC20(USDC).balanceOf(address(bridge)),
            expectedAmountAfterFee,
            "Bridge should hold max amount after fees"
        );
    }
    
    // ============ Helper Functions ============
    
    function _fundAccountWithUSDC(address account, uint256 amount) internal {
        vm.startPrank(USDC_WHALE);
        IERC20(USDC).transfer(account, amount);
        vm.stopPrank();
    }
    
    function _fundAccountWithWETH(address account, uint256 amount) internal {
        vm.startPrank(WETH_WHALE);
        IERC20(WETH).transfer(account, amount);
        vm.stopPrank();
    }
    
    function _fundAccountWithDAI(address account, uint256 amount) internal {
        vm.startPrank(DAI_WHALE);
        IERC20(DAI).transfer(account, amount);
        vm.stopPrank();
    }
    
    function _generateValidSignatures(bytes32 depositId, address recipient, uint256 amount) internal view returns (bytes[] memory) {
        uint256 currentNonce = bridge.nonces(recipient);
        uint256 deadline = block.timestamp + bridge.MESSAGE_EXPIRY();
        
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("Withdraw(bytes32 depositId,address recipient,uint256 amount,uint256 nonce,uint256 deadline)"),
                depositId,
                recipient,
                amount,
                currentNonce,
                deadline
            )
        );
        
        bytes32 domainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                keccak256("NearBridge"),
                keccak256("1.0.0"),
                block.chainid,
                address(bridge)
            )
        );
        
        bytes32 messageHash = keccak256(
            abi.encodePacked("\x19\x01", domainSeparator, structHash)
        );
        
        bytes[] memory signatures = new bytes[](2);
        
        (uint8 v1, bytes32 r1, bytes32 s1) = vm.sign(RELAYER1_KEY, messageHash);
        signatures[0] = abi.encodePacked(r1, s1, v1);
        
        (uint8 v2, bytes32 r2, bytes32 s2) = vm.sign(RELAYER2_KEY, messageHash);
        signatures[1] = abi.encodePacked(r2, s2, v2);
        
        return signatures;
    }
}
